# Push Swap Project

Shuffling brilliance meets stack sorcery in 'push_swap' â€“ an ingenious C implementation from School 42 that sorts a stack of numbers with limited operations. Brace yourself for algorithmic wizardry and witness the mastery of order unfold!

## Overview

Welcome to my Push Swap project! This repository showcases my implementation of the Push Swap algorithm, developed as part of my coursework at School 42. Push Swap is a remarkable sorting project that demonstrates my ability to solve complex problems using efficient algorithms and the C programming language.

## Project Objectives

The primary objective of the Push Swap project was to design and implement an algorithm that sorts a stack of numbers in ascending order, using only a limited set of stack operations. By completing this project, I aimed to demonstrate the following skills and qualities:

- Proficiency in the C programming language
- Understanding of algorithmic principles and efficiency
- Ability to manipulate and manage data structures, particularly stacks
- Problem-solving and critical thinking skills
- Attention to detail and code optimization
- Collaboration and adherence to project requirements

## Key Features and Highlights

### 1. Algorithmic Brilliance

In Push Swap, I employed a range of sorting algorithms, carefully selecting the most suitable ones to achieve optimal performance. The project pushed me to explore different strategies, analyze their strengths and weaknesses, and implement a combination that delivered efficient sorting results.

### 2. Stack Mastery

Manipulating stacks was at the core of this project. By skillfully implementing stack operations such as swapping, pushing, and rotating, I demonstrated my ability to navigate data structures and leverage their power to solve complex sorting challenges.

### 3. Performance and Optimization

With a keen eye for efficiency, I optimized my code to minimize unnecessary operations and reduce computational overhead. This project allowed me to sharpen my skills in algorithmic optimization, ensuring that the sorting process was as fast and streamlined as possible.

### 4. Collaboration and Adaptability

Throughout the project, I collaborated with fellow students, engaging in peer code reviews and discussions. This experience honed my ability to adapt and integrate feedback, fostering a collaborative spirit while maintaining the project's requirements and objectives.

## The Push Swap Algorithm: An Exquisite Sorting Symphony

### Stage 1: Delicate Transfers

The initial phase of the Push Swap algorithm orchestrates a delicate transfer of elements from stack_a to stack_b. It begins by constructing a temporary array that encapsulates the contents of stack_a. Employing a meticulous sorting process, the array is gracefully ordered, harmonizing the elements within.

To unveil the symmetrical beauty of the array, our algorithm strategically identifies the value occupying the position (array_size / 2). Employing this pivotal value as a reference, a selection process ensues, carefully moving all numbers smaller than this threshold to stack_b. This selective transfer repeats iteratively until stack_a retains a mere trio of mesmerized elements.

### Stage 2: The Triumphant Crescendo

As the algorithm progresses, we reach the triumphant crescendo of our symphony. Within the confined space of stack_a, the three remaining elements beckon for an ordered arrangement. Employing an uncomplicated yet effective algorithm, we elegantly sort stack_a with a maximum of two movements. This final movement sequence acts as a conductor's baton, harmonizing the trio into their predestined alignment.

### Stage 3: The Resplendent Return

But our symphony is far from complete. In stack_b, each node within our linked list holds invaluable information, guiding the elements on their return journey to the rightful abode in stack_a. These guiding whispers of knowledge wield immense power.

With precision and intellectual acuity, the algorithm calculates the optimal number of movements necessary to reintegrate each element into its rightful position within stack_a. Armed with this revelation, we embark on a meticulous search for the element that necessitates the fewest movements. Gently, we usher it back into the sanctity of stack_a, harmonizing the ensemble with a touch of refined finesse.

Driven by the pursuit of perfection, we recalculate the celestial alignments, tirelessly iterating and refining until stack_b is entirely empty, each mystical entity effortlessly transported to its designated place within stack_a.


## Conclusion

The Push Swap project has been an invaluable experience, showcasing my abilities in algorithm design, programming, and problem-solving. By mastering the intricacies of stack manipulation and crafting efficient sorting algorithms, I have demonstrated my commitment to excellence and my passion for producing high-quality code.

I invite you to explore this repository to witness my implementation of the Push Swap algorithm and to delve into the complexities of sorting through a limited set of stack operations. Brace yourself for the magic of order and the elegance of algorithmic brilliance.

Thank you for taking the time to review my work!
